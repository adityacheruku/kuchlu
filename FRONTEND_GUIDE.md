# ChirpChat Frontend: Implementation & Flow Deep Dive

This document provides a comprehensive technical guide to the ChirpChat frontend, detailing its implementation of core flows, real-time data handling, and performance strategies.

---

## 1. Core Messaging & Display Flow

### 1.1. Optimistic UI Updates & Failure Handling

**How quickly does a sent message appear?**
Instantly. The application uses **optimistic UI updates** to provide immediate feedback.

*   **Optimistic Creation:** When a user sends a message, `chat/page.tsx` immediately creates a message object with a unique `client_temp_id` (a v4 UUID) and a status of `'sending'` or `'uploading'`.
*   **Local Persistence:** This optimistic message is instantly saved to the local IndexedDB via `storageService`. The UI, powered by a `useLiveQuery` hook, reacts to this database change and renders the new message bubble.
*   **Server Confirmation:** When the real-time service receives a `message_ack` event from the server, it includes the final server-assigned `id`. The `storageService` then updates the local message, replacing the `client_temp_id` with the permanent `id` and updating the status to `'sent'`.
*   **Failure Handling:** If a message fails to send (due to a network error or a timeout defined in `chat/page.tsx`), its status is updated to `'failed'`. The `MessageBubble` component observes this status and displays a "Failed to send" message along with a "Retry" button, which allows the user to re-initiate the send process.

### 1.2. Message Uniqueness & Chronological Order

**How are messages ordered and de-duplicated?**
The system uses a combination of timestamps and unique IDs.

*   **Chronological Order:** The primary source of truth for ordering is the `created_at` timestamp on each message. The `useLiveQuery` hook continuously fetches messages from IndexedDB and sorts them by this timestamp, ensuring the display is always in the correct order.
*   **Uniqueness:** To prevent duplicates, the `client_temp_id` serves as the primary key for a message before it receives a permanent ID from the server. When the `message_ack` or a `new_message` event arrives, the `storageService` uses `put` (or `upsert`) operations. If a message with that ID already exists, it's updated; otherwise, it's inserted. This handles cases where a WebSocket event might arrive for a message that was already optimistically rendered.

### 1.3. Chat Feed Scrolling & Performance

**How does the chat feed handle long conversations?**
Through a combination of on-demand loading and component memoization.

*   **Infinite Scrolling:** The chat does not load all messages at once. `chat/page.tsx` initially fetches a batch of 50 messages. When the user scrolls to the top of the `MessageArea`, an "Load Older Messages" button becomes visible. Clicking it triggers the `loadMoreMessages` function, which fetches the next batch of older messages from the API and prepends them to the local database. The scroll position is maintained to prevent a jarring jump.
*   **Auto-Scrolling:** The `useAutoScroll` hook ensures that if the user is already near the bottom of the chat, the view automatically scrolls down when a new message arrives.
*   **Rendering Performance:** Every message bubble is wrapped in `React.memo`. This prevents the entire list from re-rendering when a single message changes (e.g., its status updates or a reaction is added).
*   **Known Limitation:** The app does **not** currently use list virtualization. For extremely long conversations (tens of thousands of messages), this could become a performance bottleneck. Implementing a library like `react-virtual` would be a future optimization.

---

## 2. Media Handling & Display

### 2.1. Upload Progress States & Cancellation

**How is upload progress communicated?**
The `uploadManager` and `MessageBubble` work together to show granular progress.

*   **States:** The `UploadItem` has several statuses: `pending`, `compressing` (for video/audio), `uploading` (direct-to-Cloudinary), `pending_processing` (waiting for webhook), and `failed`.
*   **UI Feedback:** The `UploadProgressIndicator` component, shown within a `MessageBubble`, displays the current state. It shows a percentage for the upload and specific text like "Compressing..." or "Processing..." for other stages.
*   **Cancellation:** There is not currently a user-facing UI to cancel an upload in progress. This is a potential future enhancement.

### 2.2. Media Playback Experience

**How is media playback optimized?**
By using a dedicated player library and leveraging the multiple media formats generated by Cloudinary.

*   **Adaptive Streaming:** The `VideoPlayer` component uses `react-player`, which internally supports `hls.js`. When rendering a video, it first requests a signed URL for the `hls_manifest` from the backend. If available, it provides a smooth, adaptive streaming experience. If not, it falls back to a direct MP4 link.
*   **Previews:** The player uses the `static_thumbnail` URL from the `media_metadata` as the poster image, ensuring a fast initial render.
*   **Loading/Buffering:** The player library handles its own internal loading and buffering indicators.

### 2.3. Image Display

**How are images optimized?**
The application uses Cloudinary's transformations and requests signed URLs for specific versions.

*   **`next/image` is not used** for chat media because the URLs are dynamic (signed and short-lived), which is not the primary use case for `next/image`'s static optimization.
*   Instead, the `SecureMediaImage` component requests a signed URL for a `preview_800` (an 800px wide, optimized WebP) or `thumbnail_250` version of the image, ensuring that a reasonably sized, compressed image is loaded, not the multi-megabyte original.

---

## 3. Real-time Updates & WebSocket Integration

### 3.1. Reconnection Strategy

**What happens when the connection drops?**
The `realtimeService` is designed to be resilient.

*   **Detection:** It uses the browser's `navigator.onLine` API and WebSocket `onclose`/`onerror` events to detect connection loss.
*   **Fallback:** If the WebSocket connection fails, it automatically falls back to a Server-Sent Events (SSE) connection, providing a read-only channel for receiving messages.
*   **Reconnection:** If both connections fail, it enters a `disconnected` state and attempts to reconnect periodically using an exponential backoff strategy managed by `scheduleReconnect`.
*   **Synchronization:** Upon successful reconnection, it immediately calls the `/events/sync` API endpoint, sending the `lastSequence` number it has stored. The backend returns all events that have occurred since, which are then processed to fill in any missed messages or updates, ensuring data consistency.

### 3.2. Event Handling

All WebSocket events are piped through a single `handleEvent` function in `realtimeService`, which then uses a `switch` statement to call the appropriate callback (e.g., `onMessageReceived`, `onPresenceUpdate`). This centralized approach, combined with the specific state update logic in `chat/page.tsx`, ensures that updates are handled efficiently without causing excessive re-renders of the entire component tree.

---

## 4. Offline Experience & Persistence

### 4.1. Message Persistence (Outbox/Inbox)

**Does the app work offline?**
Yes, it has robust offline capabilities.

*   **Outbox (Sending):** The `uploadManager` is built on top of the `storageService` (IndexedDB). When a user sends a message or media file while offline, it is added to the persistent `uploadQueue` table in IndexedDB. When `networkMonitor` detects that the connection is restored, it automatically calls `processQueue` to send all queued items.
*   **Inbox (Receiving):** The app is a PWA with a service worker. When offline, the user can still receive push notifications for new messages. When they open the app, the `syncEvents` mechanism ensures all messages they missed are fetched from the server and integrated into the local chat history.

### 4.2. Local Data Storage

*   **Database:** The app uses **Dexie.js** to manage an IndexedDB database (`ChirpChatDB`). This database stores all chats, messages, users, and the upload queue. This ensures the entire chat history is available offline.
*   **Synchronization:** The primary sync mechanism is the `syncEvents` call on startup and reconnection. This is a "last write wins" model where the server is the source of truth, and the client "catches up" to it. There is no complex conflict resolution, as a user can only write from one active client at a time.

---

## 5. Performance & Responsiveness

### 5.1. Rendering Performance

As mentioned in section 1.3, performance is primarily managed by **`React.memo`** on the `MessageBubble` component. The lack of list virtualization is a known area for future improvement.

### 5.2. Input Responsiveness

The chat input bar is a separate component from the message list. User typing and input state changes do not trigger re-renders of the `MessageArea`, ensuring that the typing experience remains smooth and responsive regardless of other activity.

---

## 6. Error Handling & User Feedback

### 6.1. User-Friendly Errors

The system provides both global and local error feedback.

*   **Global Errors:** A connection status banner appears at the top of the screen for critical, app-wide issues like being offline or connected via a slower SSE fallback. `useToast` is used for authentication failures.
*   **Local Errors:**
    *   **Message Send Failure:** Handled directly on the `MessageBubble` with a "Retry" button.
    *   **Media Upload Failure:** The `UploadProgressIndicator` shows a "Failed" state. `uploadManager` also attempts to parse specific error messages from Cloudinary to provide more context.
    *   **Signed URL Failure:** The `useSignedUrl` hook has an error state. If a signed URL fails to load, the `MediaDisplay` component will show a "Could not load media" error message.

---

## 7. Frontend Security

### 7.1. API Key Exposure

No sensitive keys are exposed on the client. The Cloudinary API secret is used only by the backend to generate signatures. The client only ever receives the temporary, safe-to-use signature.

### 7.2. XSS Protection

The application does not render user-generated content as HTML. All message text is rendered as text content within React components, which automatically protects against Cross-Site Scripting (XSS) attacks. If rich text or HTML content were to be introduced, a sanitization library (like DOMPurify) would be required.
